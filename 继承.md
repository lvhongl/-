[TOC]

# 代码块

## 概述

1、使用大括号包起来的一段代码。放在不同的位置，有不同的名称，有不同的作用，有不同的执行时机。

2、分类：

 局部代码块

 构造代码块

 静态代码块

 同步代码块（多线程）

## 局部代码块

1、格式：使用大括号包起来的一段代码

2、位置：方法中

3、作用：

 限定变量的生命周期，作用域只是在大括号内部

 在局部代码块中【声明】的变量，只能在局部代码块的范围内使用，一旦出了局部代码块的大括号，变量就不能继续使用了。

 某个变量一旦不能使用了，就会被回收，节省内存空间

4、注意事项：

 如果是在局部代码块中声明了变量，会减少变量的声明周期，出了局部代码块就无法继续使用局部代码块中声明的变量。

 如果是在局部代码块中修改了局部代码块外声明的变量，局部代码块结束之后，并不会消除局部代码块对这个变量的修改。

代码示例：

```java
public static void main(String[] args) {
    int i = 10;
    {
        System.out.println(i);//10
        i = 20;
        int j = 100;
        System.out.println(j);//100
    }

    System.out.println(i);//20，局部代码块只对其中声明的变量有效果，对于变量的使用还是和以前一样
    //System.out.println(j);不能访问局部代码块中声明的变量
}
```

## 构造代码块

1、格式：使用大括号包起来的一段代码

2、位置：类中方法外

3、作用：

 用于给成员变量初始化赋值

4、构造代码块的执行说明：

 1、在创建对象的时候执行，由jvm默认调用

 2、在构造方法执行之前，执行

 3、任意一个构造方法执行之前，都会执行一次构造代码块的内容

 4、如果每个构造方法都会执行的内容，请提取到构造代码块中执行

## 静态代码块【常用】

1、格式：

 static {

  	静态代码块的内容

}

2、位置：类中方法外

3、作用：

 用于给静态的成员变量初始化赋值

 用于执行那些只需要执行一次的代码，例如驱动加载等

4、执行特点：

 1、随着类的加载而执行

 2、类只加载一次，所以静态代码块只执行一次

 3、执行的时机最早：早于所有的对象相关内容，比main方法执行的早

# 继承

## 继承的概述

1、让类与类产生关系，子父类的关系

2、关键字：extends，扩展、增加、继承

3、父类和子类：

 父类：被继承的类，超类、基类

 子类：用于继承的类，派生类

代码示例1 没有使用继承

代码示例2 使用继承



## 继承的好处和弊端

1、好处：

 提高了代码的复用性

 提高了代码的可维护性

 是多态的前提

2、弊端：

 提高了代码的耦合性

 耦合性：事物与事物之间的依赖关系，互相影响的程度

3、开发原则：面向对象最终要实现得目的

​	   高内聚: 一个对象自身可以完成所有的东⻄

​	  低耦合 ：对于其他代码的依赖性非常低

​	代码的复用性高

## 继承的注意事项

1、私有的成员不能被继承

​	 父类中有一些私有成员，不能在子类中直接使用

2、父类中的构造方法，不能继承

​		原因：

   父类的构造方法需要和父类的类名一致、子类的构造方法需要和子类类名一致，父类和子类的类名不一样。因此无法继承，名称有冲突。

  父类的构造方法用于给父类的成员变量赋值，子类的构造方法用于给子类的成员变量赋值，子类的成员变量较多，使用父类的构造方法无法将子类中所有的成员变量都进行赋值，因此不继承父类的构造方法。

解决：

 子类不继承父类的构造，但是可以【调用】父类的构造方法。Super

3、继承的设计：不要为了部分功能而定义继承

 程序员类：姓名、年龄、工号、工资、工作

 项目经理：姓名、年龄、工号、工资、工作、奖金

 继承关系：子类是父类的一种， is a，狗是动物的一种

 解决：将程序员和项目经理向上抽取一个“员工类”

## 继承中成员变量的关系

1、在子父类中定义了不同名称的成员变量，在子类中，既可以访问子类的成员变量，也可以访问父类的成员变量。

2、在子父类中定义了同名的成员变量，在子类中，根据就近原则来访问

 在子类的方法中，如果访问了某个变量名称，优先在当前方法中，寻找该变量的定义，如果找到了就使用方法中的局部变量；如果没有找到，就到子类的成员位置寻找该变量的定义，如果找到了就使用子类的成员变量；如果没有找到，就到父类的成员位置寻找该变量的定义....一直往上找，一直到Object类中，如果还没有找到，就编译报错。

##### 代码示例:

```java
public class Test01 {
    public static void main(String[] args) {
        Fu f = new Fu();
        System.out.println(f.a);//10
        //System.out.println(f.b);在父类中没有定义b

        Zi z = new Zi();
        System.out.println(z.a);//10
        System.out.println(z.b);//20
        z.test();
    }
}

class Fu {
    int a = 10;
    int c = 10;
}

class Zi extends Fu {
    int b = 20;
    int a = 100;

    /*public void test(int a) {
        System.out.println(a);//1000
    }*/
    public void test() {
        System.out.println(a);//100
    }

    public void test2() {
        System.out.println(c);//10
        //System.out.println(d);找不到d这个变量符号  编译报错
    }
}
```

## 关键字this和super的详细解释

1、this和super：

​	 this表示本类当前对象的引用

​	 super表示本类当前对象父类的引用

### this和super使用总结

1、含义：

 this关键字表示本类当前对象的引用

  哪个对象在调用this所在的方法，this就表示哪个对象

 super关键字表示本类当前对象的父类的引用

  哪个对象在调用super所在的方法，super就表示哪个对象中的父类部分的数据

## 继承中构造方法的关系

1、在初始化子类数据之前，必须先完成对父类数据的初始化（因为在初始化子类数据的时候，可能会使用到父类中的数据，所以必须先把父类数据准备好）

2、如果在子类的构造方法中，没有显式的调用任何其他构造方法（本类、父类），在构造方法的第一句，系统默认给你加上super()，默认要访问父类的空参构造

3、如果在子类的构造方法中，手动增加了访问父类的构造方法，那么系统将不给你增加任何构造方法的访问

4、如果在子类的构造方法中，手动增加了访问本类的其他构造方法，那么系统将不给你增加任何构造方法的访问

5、构造方法不能递归调用

​    构造方法不能自己直接访问自己，也不能自己间接的访问自己

​    this();  

​	this(color);

6、总结：

 1、【目标】子类的构造方法，一定要先访问父类的构造方法

 2、特点： 	

  【this语句】和【super语句】必须在构造方法的第一行

​       super语句在第一句是为了保证父类的构造方法必须先执行

   在构造方法中，【this语句】和【super语句】不能共存

​      因为： this语句和super语句都要在构造方法的第一行

  【this语句】和【super语句】不能出现在其他非构造方法的非静态成员方法中

# 重写

1、在子父类中，出现了不同名的方法

 子类可以直接调用父类的方法，也可以调用子类的特有方法

2、在子父类中，出现了同名的方法

 在子父类中，出现了一模一样的方法声明，而两个方法的实现内容却不一样

 作用：在子类中，如果你不想修改父类中的方法声明，但是还想修改方法的实现内容，这时候就需要使用重写。

3、方法的重写和方法的重载：

 重载：在同一个类中，方法名相同，参数列表不同，与返回值类型无关

 重写：在子父类中，方法名相同，参数列表相同，与返回值类型有关（相同）

  别名：Override，覆写、覆盖

4、方法重写的检查：

 关键字： @Override

 让编译器帮助我们检查，当前的这个方法，究竟是否是对父类方法的重写。

5、说明：

 方法本身还是属于父类，只是在子类中重新实现了这个方法的内容。

代码示例：

```java
public class Test01 {
    public static void main(String[] args) {
        DayOne d = new DayOne();
        d.唱红歌();
        d.泡妞();
    }
}

class DoubleRiver {
    public void 唱红歌() {
        System.out.println("小小竹筏江中游");
    }

    public void 泡妞() {
        System.out.println("通过唱红歌搞定林夕合鸟女士");
    }
}

class DayOne extends DoubleRiver {
    @Override
    public void 泡妞() {
        System.out.println("霸王硬上弓");
    }
}
```

## 重写的注意事项

1、私有的方法不能被重写

 父类中私有的方法，在子类中根本就看不到，继承不下来，就不能重写。子类可以自己定义一个和父类私有方法同名的方法，也不算重写，只能算是新定义了一个方法。

 重写：使用父类的方法定义，修改为子类的实现。

2、方法在重写的时候，权限不能越来越小

3、访问修饰符：

​	 子类应该是越来越强大，功能越来越多，将父类中拥有的方法，重写没了。

​	 java的四个关键字：public、protected、default、private

​	适用范围<访问权限范围越小，安全性越高>

<img src="https://s2.loli.net/2023/07/10/LFKum5TgP2OEpnQ.png" alt="image-20230710161519396" style="zoom:50%;" />



## 访问修饰符修饰类：

**private**（私有的）无法访问：使用private关键字，就意味着被声明的成员或方法，除了本类，其他任何类都无法访问。

**public**（公共的）接口访问权限：使用public关键字，就意味着被声明的成员或方法对所有类都是可以访问的。

**protected**（受保护的）继承访问权限：使用protected关键字，就意味着被声明的成员或方法，在子类以及相同包内的其他类都是可以访问的。

**default**（默认的）包访问权限：即不写任何关键字，就意味着相同包内的其他类（包括子类）可以访问，包外都不可以访问。

## Java中继承的特点

1、Java支持单继承，不支持多继承，java支持多层继承

 单继承：一个子类只能继承一个父类（一个孩子只能有一个亲爹）

 多继承：一个子类不能同时继承多个父类

 多层继承：A类可以继承B类，B类可以继承C类，A类中拥有B、C类中的所有属性和方法。说明：越是顶层的类，定义的功能越是共性功能，功能和属性就越少；越是底层的类，定义的特有功能和属性就越多，就更加强大。学习一个体系的时候，先学顶层的类，共性功能学习完，学习底层特有的方法即可；使用一个类创建对象的时候，选择底层的类型，功能更多更强大。

2、原因：

 如果支持多继承，那么可能一个子类继承了两个父类，两个父类中有相同的方法声明，却拥有不同的方法实现。子类继承之后，就不知道该走哪个父类的方法实现了。（安全隐患）

# final关键字

1、单词含义：最终的，最后的，表示不能再改变的。

2、final关键字：可以修饰类、方法、变量

3、修饰类：

表示一个最终类，表示不能有子类，【不能被其他类继承】

一旦一个类型不能被继承，那么其中所有的方法都不能被重写

不影响当前类的方法被调用

4、修饰方法：

  表示一个最终方法，【该方法不能被重写】，

   父类中被final修饰的方法 子类是可以继承到的

5、修饰变量：

 表示一个最终变量，该【变量变成了常量】，就只能赋值一次，不能二次赋值了

 当前项目中，常用的常量一般都定义在一个类的成员位置，甚至专门定义一个常量类

 定义常量的好处：见名知意，容易理解；可维护性高

public static final double PI = 3.14;

